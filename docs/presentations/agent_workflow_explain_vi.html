<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Agent Workflow Explain</title>
  <script src="./assets/js/go.js"></script>
  <link rel="stylesheet" href="./assets/css/font-awesome.min.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background-color: #fff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0,0,0,0.1);
    }
    h1 {
      text-align: center;
      color: #333;
    }
    .content-wrapper {
      display: flex;
      flex-direction: row;
      gap: 20px;
    }
    .diagram-panel {
      flex: 1;
      min-width: 0;
    }
    .info-panel {
      flex: 0 0 400px;
      height: 700px;
      display: flex;
      flex-direction: column;
      background-color: #f9f9f9;
      border-radius: 5px;
      border: 1px solid #ddd;
      padding: 15px;
      overflow: hidden;
    }
    #myDiagramDiv {
      width: 100%;
      height: 700px;
      border: 1px solid #d3d3d3;
      background-color: #fff;
    }
    .buttons {
      text-align: center;
      margin: 20px 0;
    }
    .control-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: none;
      margin: 0 10px;
      font-size: 20px;
      cursor: pointer;
      color: white;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .control-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    }
    .control-btn:active {
      transform: translateY(1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .btn-start {
      background-color: #52c41a;
    }
    .btn-pause {
      background-color: #faad14;
    }
    .btn-continue {
      background-color: #1890ff;
    }
    .btn-reset {
      background-color: #ff4d4f;
    }
    .btn-start:hover {
      background-color: #389e0d;
    }
    .btn-pause:hover {
      background-color: #d48806;
    }
    .btn-continue:hover {
      background-color: #096dd9;
    }
    .btn-reset:hover {
      background-color: #cf1322;
    }
    .control-btn:disabled {
      background-color: #d9d9d9;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .details-section {
      margin-bottom: 20px;
    }
    #message {
      padding: 10px;
      background-color: #f0f0f0;
      border-radius: 5px;
      font-family: monospace;
      min-height: 60px;
      margin-top: 10px;
    }
    .log-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .log {
      flex: 1;
      overflow-y: auto;
      border: 1px solid #ddd;
      padding: 10px;
      background-color: #f5f5f5;
      border-radius: 5px;
      margin-top: 10px;
    }
    .log-item {
      margin-bottom: 5px;
      padding: 5px;
      border-radius: 3px;
    }
    .log-user {
      background-color: #e6f7ff;
      border-left: 3px solid #1890ff;
    }
    .log-planning {
      background-color: #f6ffed;
      border-left: 3px solid #52c41a;
    }
    .log-jira {
      background-color: #fff1f0;
      border-left: 3px solid #ff4d4f;
    }
    .log-slack {
      background-color: #fffbe6;
      border-left: 3px solid #faad14;
    }
    .log-confluence {
      background-color: #f9f0ff;
      border-left: 3px solid #722ed1;
    }
    .node-details {
      max-width: 200px;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .node-active {
      font-weight: bold;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Agent Workflow Explain</h1>
    
    <div class="buttons">
      <button id="startDemo" class="control-btn btn-start" title="B·∫Øt ƒë·∫ßu Demo">
        <i class="fas fa-play"></i>
      </button>
      <button id="pauseDemo" class="control-btn btn-pause" disabled title="T·∫°m d·ª´ng">
        <i class="fas fa-pause"></i>
      </button>
      <button id="continueDemo" class="control-btn btn-continue" disabled title="Ti·∫øp t·ª•c">
        <i class="fas fa-forward"></i>
      </button>
      <button id="resetDemo" class="control-btn btn-reset" title="L√†m l·∫°i">
        <i class="fas fa-redo"></i>
      </button>
    </div>
    
    <div class="content-wrapper">
      <div class="diagram-panel">
        <div id="myDiagramDiv"></div>
      </div>
      
      <div class="info-panel">
        <div class="details-section">
          <h3>Chi ti·∫øt h√†nh ƒë·ªông:</h3>
          <div id="message">Ch·ªçn "B·∫Øt ƒë·∫ßu Demo" ƒë·ªÉ b·∫Øt ƒë·∫ßu.</div>
        </div>
        
        <div class="log-section">
          <h3>Nh·∫≠t k√Ω th·ª±c thi:</h3>
          <div id="log" class="log"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Kh·ªüi t·∫°o diagram
    const $ = go.GraphObject.make;
    
    const myDiagram = new go.Diagram("myDiagramDiv", {
      "undoManager.isEnabled": true,
      "initialAutoScale": go.Diagram.Uniform,
      "initialContentAlignment": go.Spot.Center,
      // V√¥ hi·ªáu h√≥a layout t·ª± ƒë·ªông v√† th√™m fixedBounds
      layout: $(go.LayeredDigraphLayout, { 
        isInitial: false,  // Kh√¥ng d√πng layout khi kh·ªüi t·∫°o
        isOngoing: false,  // Kh√¥ng t·ª± ƒë·ªông √°p d·ª•ng layout
        direction: 90,
        layerSpacing: 50,
        columnSpacing: 30,
        setsPortSpots: false
      })
    });
    
    // ƒê·ªãnh nghƒ©a template cho c√°c node
    myDiagram.nodeTemplate =
      $(go.Node, "Auto",
        { 
          selectionAdorned: false, 
          resizable: false,
          locationSpot: go.Spot.Center, // Th√™m locationSpot
          movable: false  // Kh√¥ng cho ph√©p di chuy·ªÉn node
        },
        $(go.Shape, "RoundedRectangle", {
          fill: "white", strokeWidth: 2,
          portId: "", fromLinkable: true, toLinkable: true, cursor: "pointer",
          stroke: "gray",
          name: "SHAPE"  // Th√™m name ƒë·ªÉ d·ªÖ d√†ng truy c·∫≠p ƒë·ªëi t∆∞·ª£ng h√¨nh d·∫°ng
        },
        new go.Binding("fill", "color"),
        new go.Binding("stroke", "borderColor")),
        $(go.Panel, "Vertical",
          { margin: 8 },
          $(go.TextBlock, 
            { 
              margin: new go.Margin(0, 0, 5, 0),
              font: "bold 14px sans-serif", 
              stroke: "#333",
              alignment: go.Spot.Center
            },
            new go.Binding("text", "name")),
          $(go.Panel, "Vertical",
            { 
              background: "white", 
              margin: new go.Margin(5, 0, 0, 0),
              maxSize: new go.Size(200, NaN)
            },
            new go.Binding("visible", "showDetails"),
            $(go.TextBlock, 
              { 
                margin: 5,
                font: "12px sans-serif",
                stroke: "#555",
                wrap: go.TextBlock.WrapFit,
                alignment: go.Spot.Left,
                name: "DETAILS"  // Th√™m name ƒë·ªÉ c·∫≠p nh·∫≠t realtime
              },
              new go.Binding("text", "details")),
            $(go.TextBlock, 
              { 
                margin: 5,
                font: "12px sans-serif",
                stroke: "#e91e63",
                wrap: go.TextBlock.WrapFit,
                alignment: go.Spot.Left,
                name: "CURRENT_ACTION",
                visible: false  // ·∫®n ban ƒë·∫ßu
              })
          )
        )
      );
    
    // ƒê·ªãnh nghƒ©a template cho c√°c link
    myDiagram.linkTemplate =
      $(go.Link,
        { 
          routing: go.Link.AvoidsNodes,
          curve: go.Link.JumpOver,
          corner: 10,
          toShortLength: 4
        },
        $(go.Shape, { 
          strokeWidth: 2,
          name: "SHAPE"  // Th√™m name ƒë·ªÉ d·ªÖ d√†ng truy c·∫≠p ƒë·ªëi t∆∞·ª£ng h√¨nh d·∫°ng
        },
          new go.Binding("stroke", "color")),
        $(go.Shape, { toArrow: "Standard", stroke: null, scale: 1.5 },
          new go.Binding("fill", "color")),
        $(go.Panel, "Auto",
          $(go.Shape, "RoundedRectangle", {
            fill: "white", stroke: "gray",
            minSize: new go.Size(50, 20)
          }),
          $(go.TextBlock, {
            margin: 5,
            font: "11px sans-serif",
            stroke: "#333",
            name: "LINK_TEXT"  // Th√™m name ƒë·ªÉ c·∫≠p nh·∫≠t realtime
          },
          new go.Binding("text", "text"))
        )
      );
    
    // T·∫°o d·ªØ li·ªáu cho c√°c node v·ªõi v·ªã tr√≠ c·ªë ƒë·ªãnh
    const nodeDataArray = [
      { 
        key: "user", 
        name: "User", 
        details: "ƒê·∫ßu v√†o",
        color: "#f5f5f5", 
        activeColor: "#e6f7ff",
        borderColor: "#d9d9d9",
        activeBorderColor: "#1890ff",
        showDetails: true,
        // V·ªã tr√≠ node t·ª´ h√¨nh ·∫£nh
        loc: "370 85"
      },
      { 
        key: "planning", 
        name: "Planning Agent", 
        details: "Ph√¢n t√≠ch tin nh·∫Øn v√† l√™n k·∫ø ho·∫°ch",
        color: "#f5f5f5", 
        activeColor: "#f6ffed",
        borderColor: "#d9d9d9",
        activeBorderColor: "#52c41a",
        showDetails: true,
        // V·ªã tr√≠ node t·ª´ h√¨nh ·∫£nh
        loc: "370 255"
      },
      { 
        key: "action_plan", 
        name: "Action Plan", 
        details: "",  // B·∫Øt ƒë·∫ßu v·ªõi chi ti·∫øt tr·ªëng
        color: "#f0f7ff", 
        activeColor: "#f0f7ff",
        borderColor: "#91caff",
        activeBorderColor: "#1677ff",
        showDetails: true,
        // V·ªã tr√≠ node t·ª´ h√¨nh ·∫£nh
        loc: "617 128"
      },
      { 
        key: "jira", 
        name: "Jira Agent", 
        details: "T∆∞∆°ng t√°c v·ªõi Jira API",
        color: "#f5f5f5", 
        activeColor: "#fff1f0",
        borderColor: "#d9d9d9",
        activeBorderColor: "#ff4d4f",
        showDetails: true,
        // V·ªã tr√≠ node t·ª´ h√¨nh ·∫£nh
        loc: "106 394"
      },
      { 
        key: "slack", 
        name: "Slack Agent", 
        details: "T∆∞∆°ng t√°c v·ªõi Slack API",
        color: "#f5f5f5", 
        activeColor: "#fffbe6",
        borderColor: "#d9d9d9",
        activeBorderColor: "#faad14",
        showDetails: true,
        // V·ªã tr√≠ node t·ª´ h√¨nh ·∫£nh
        loc: "370 514"
      },
      { 
        key: "confluence", 
        name: "Confluence Agent", 
        details: "T∆∞∆°ng t√°c v·ªõi Confluence API",
        color: "#f5f5f5", 
        activeColor: "#f9f0ff",
        borderColor: "#d9d9d9",
        activeBorderColor: "#722ed1",
        showDetails: true,
        // V·ªã tr√≠ node t·ª´ h√¨nh ·∫£nh
        loc: "634 391"
      }
    ];
    
    // T·∫°o d·ªØ li·ªáu cho c√°c link
    const linkDataArray = [
      { from: "user", to: "planning", color: "#1890ff", text: "input" },
      { from: "planning", to: "action_plan", color: "#52c41a", text: "t·∫°o" },
      { from: "planning", to: "jira", color: "#52c41a", text: "ra l·ªánh" },
      { from: "planning", to: "slack", color: "#52c41a", text: "ra l·ªánh" },
      { from: "planning", to: "confluence", color: "#52c41a", text: "ra l·ªánh" }
    ];
    
    // X·ª≠ l√Ω ·∫©n hi·ªán c√°c link tr√πng nhau
    function avoidDuplicateLinks(model) {
      const linkKeys = {};
      model.linkDataArray.forEach((linkData, i) => {
        const key = linkData.from + "," + linkData.to;
        if (key in linkKeys) {
          const firstIdx = linkKeys[key];
          const firstLink = model.linkDataArray[firstIdx];
          
          // ƒêi·ªÅu ch·ªânh cong cho c·∫£ hai links
          if (!firstLink.curviness) firstLink.curviness = 20;
          if (!linkData.curviness) linkData.curviness = -20;
        } else {
          linkKeys[key] = i;
        }
      });
    }
    
    // Kh·ªüi t·∫°o m√¥ h√¨nh v·ªõi d·ªØ li·ªáu
    myDiagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);
    avoidDuplicateLinks(myDiagram.model);

    // ƒê·∫∑t v·ªã tr√≠ cho m·ªói node
    myDiagram.nodes.each(node => {
      const data = node.data;
      if (data.loc) {
        const pos = go.Point.parse(data.loc);
        node.location = pos;
      }
    });

    // ƒê·∫£m b·∫£o DOM ƒë√£ t·∫£i xong
    document.addEventListener('DOMContentLoaded', function() {
      console.log("DOM fully loaded");
      
      // X·ª≠ l√Ω animation
      const messageBox = document.getElementById("message");
      const logBox = document.getElementById("log");
      const startButton = document.getElementById("startDemo");
      const pauseButton = document.getElementById("pauseDemo");
      const continueButton = document.getElementById("continueDemo");
      const resetButton = document.getElementById("resetDemo");
      
      console.log("Elements found:", {
        messageBox: messageBox !== null,
        logBox: logBox !== null,
        startButton: startButton !== null,
        pauseButton: pauseButton !== null,
        continueButton: continueButton !== null,
        resetButton: resetButton !== null
      });
      
      // Bi·∫øn ki·ªÉm so√°t animation
      let animationPaused = false;
      let animationRunning = false;
      let animationResolve = null;
      
      // C√°c h√†m ti·ªán √≠ch
      async function sleep(ms) {
        // N·∫øu animation ƒëang b·ªã t·∫°m d·ª´ng, t·∫°o m·ªôt promise s·∫Ω ƒë∆∞·ª£c gi·∫£i quy·∫øt khi ti·∫øp t·ª•c
        if (animationPaused) {
          await new Promise(resolve => {
            animationResolve = resolve;
          });
        }
        
        // Sleep b√¨nh th∆∞·ªùng
        await new Promise(resolve => {
          setTimeout(() => {
            // Ki·ªÉm tra n·∫øu animation b·ªã t·∫°m d·ª´ng sau timeout
            if (animationPaused) {
              animationResolve = resolve;
            } else {
              resolve();
            }
          }, ms);
        });
      }
      
      function updateNodeDetails(nodeKey, newDetails) {
        const node = myDiagram.findNodeForKey(nodeKey);
        if (node) {
          // C·∫≠p nh·∫≠t d·ªØ li·ªáu model
          myDiagram.model.commit(m => {
            m.set(node.data, "details", newDetails);
          });
        }
      }
      
      function updateCurrentAction(nodeKey, action, isActive = true) {
        const node = myDiagram.findNodeForKey(nodeKey);
        if (node) {
          // T√¨m textblock cho current action
          const textBlock = node.findObject("CURRENT_ACTION");
          if (textBlock) {
            textBlock.text = action;
            textBlock.visible = action !== "";
            
            // Th√™m/x√≥a class node-active
            if (isActive) {
              textBlock.className = "node-active";
              
              // Thay ƒë·ªïi m√†u node khi active
              const nodeData = myDiagram.model.nodeDataArray.find(n => n.key === nodeKey);
              if (nodeData) {
                myDiagram.model.commit(m => {
                  m.set(nodeData, "color", nodeData.activeColor);
                  m.set(nodeData, "borderColor", nodeData.activeBorderColor);
                });
                
                const shape = node.findObject("SHAPE");
                if (shape) {
                  shape.stroke = nodeData.activeBorderColor;
                }
              }
            } else {
              textBlock.className = "";
              
              // ƒê·∫∑t l·∫°i m√†u node khi kh√¥ng active
              const nodeData = myDiagram.model.nodeDataArray.find(n => n.key === nodeKey);
              if (nodeData) {
                myDiagram.model.commit(m => {
                  m.set(nodeData, "color", "#f5f5f5");
                  m.set(nodeData, "borderColor", "#d9d9d9");
                });
                
                const shape = node.findObject("SHAPE");
                if (shape) {
                  shape.stroke = "#d9d9d9";
                }
              }
            }
          }
        }
      }
      
      function clearAllCurrentActions() {
        nodeDataArray.forEach(nodeData => {
          updateCurrentAction(nodeData.key, "", false);
        });
      }
      
      function highlightNode(nodeKey, duration = 2000) {
        console.log("Highlighting node:", nodeKey);
        const node = myDiagram.findNodeForKey(nodeKey);
        if (node) {
          const shape = node.findObject("SHAPE");
          if (shape) {
            // Thay ƒë·ªïi m√†u n·ªÅn v√† vi·ªÅn khi active
            const nodeData = myDiagram.model.nodeDataArray.find(n => n.key === nodeKey);
            if (nodeData) {
              myDiagram.model.commit(m => {
                m.set(nodeData, "color", nodeData.activeColor);
                m.set(nodeData, "borderColor", nodeData.activeBorderColor);
              });
              shape.stroke = nodeData.activeBorderColor;
              shape.strokeWidth = 3;
            }
            
            setTimeout(() => {
              // ƒê·∫∑t l·∫°i m√†u g·ªëc sau khi h·∫øt th·ªùi gian highlight
              if (nodeData) {
                const currentAction = node.findObject("CURRENT_ACTION");
                // Ch·ªâ ƒë·∫∑t l·∫°i m√†u n·∫øu node kh√¥ng c√≤n active (kh√¥ng c√≥ current action)
                if (!currentAction || !currentAction.visible) {
                  myDiagram.model.commit(m => {
                    m.set(nodeData, "color", "#f5f5f5");
                    m.set(nodeData, "borderColor", "#d9d9d9");
                  });
                  shape.stroke = "#d9d9d9";
                }
                shape.strokeWidth = 2;
              }
            }, duration);
          } else {
            console.error("Shape not found in node:", nodeKey);
          }
        } else {
          console.error("Node not found:", nodeKey);
        }
      }
      
      function highlightLink(fromKey, toKey, text, duration = 1500) {
        let foundLink = false;
        myDiagram.links.each(link => {
          if (link.fromNode && link.toNode && 
              link.fromNode.key === fromKey && 
              link.toNode.key === toKey && 
              link.data.text === text) {
            
            const shape = link.findObject("SHAPE");
            if (shape) {
              shape.strokeWidth = 3;
              
              setTimeout(() => {
                if (shape) {
                  shape.strokeWidth = 2;
                }
              }, duration);
              
              foundLink = true;
            }
          }
        });
        
        if (!foundLink && text !== "") {
          console.warn("Link not found:", fromKey, "->", toKey, text);
          
          // N·∫øu kh√¥ng t√¨m th·∫•y link v·ªõi text, th·ª≠ t√¨m link kh√¥ng c√≥ text
          myDiagram.links.each(link => {
            if (link.fromNode && link.toNode && 
                link.fromNode.key === fromKey && 
                link.toNode.key === toKey && 
                link.data.text === "") {
              
              const shape = link.findObject("SHAPE");
              if (shape) {
                shape.strokeWidth = 3;
                
                setTimeout(() => {
                  if (shape) {
                    shape.strokeWidth = 2;
                  }
                }, duration);
                
                foundLink = true;
              }
            }
          });
        }
      }
      
      function updateMessage(text) {
        console.log("Updating message:", text);
        messageBox.innerText = text;
      }
      
      function addLogEntry(agentType, message) {
        // Ki·ªÉm tra xem tin nh·∫Øn ƒë√£ t·ªìn t·∫°i ch∆∞a
        const existingItems = logBox.querySelectorAll('.log-item');
        for (let i = 0; i < existingItems.length; i++) {
          if (existingItems[i].innerText === message) {
            console.log("Duplicate message, skipping:", message);
            return; // Kh√¥ng th√™m tin nh·∫Øn tr√πng l·∫∑p
          }
        }
        
        const logItem = document.createElement("div");
        logItem.className = "log-item log-" + agentType;
        logItem.innerText = message;
        logBox.appendChild(logItem);
        logBox.scrollTop = logBox.scrollHeight;
      }
      
      function clearLog() {
        console.log("Clearing log");
        logBox.innerHTML = "";
      }
      
      function updateActionPlan(step, isActive = true) {
        const node = myDiagram.findNodeForKey("action_plan");
        if (node) {
          // T√¨m ki·∫øm t·∫•t c·∫£ c√°c b∆∞·ªõc trong action plan
          const details = node.findObject("DETAILS");
          if (details) {
            let stepsText = "";
            
            // N·∫øu step l√† 0 v√† kh√¥ng active, ƒë·ªÉ tr·ªëng
            if (step === 0 && !isActive) {
              details.text = "";
              return;
            }
            
            const allSteps = [
              "Ki·ªÉm tra Jira tasks h√¥m nay",
              "Xem logs Slack", 
              "Logwork v√† c·∫≠p nh·∫≠t status",
              "Vi·∫øt daily meeting notes"
            ];
            
            for (let i = 0; i < allSteps.length; i++) {
              let stepPrefix = "";
              
              if (i+1 < step) {
                // B∆∞·ªõc ƒë√£ ho√†n th√†nh
                stepPrefix = "‚úÖ ";
              } else if (i+1 === step && isActive) {
                // B∆∞·ªõc hi·ªán t·∫°i
                stepPrefix = "üîÑ ";
                if (i === 1) { // B∆∞·ªõc 2 - xem logs Slack
                  allSteps[i] += " (ƒëang th·ª±c hi·ªán)";
                }
              } else {
                // C√°c b∆∞·ªõc ch∆∞a th·ª±c hi·ªán
                stepPrefix = "‚¨ú ";
              }
              
              stepsText += `${stepPrefix}${i+1}. ${allSteps[i]}\n`;
            }
            
            // C·∫≠p nh·∫≠t n·ªôi dung
            details.text = stepsText.trim();
            
            // Highlight node n·∫øu ƒëang active
            if (isActive) {
              highlightNode("action_plan");
            }
          }
        }
      }
      
      // X·ª≠ l√Ω s·ª± ki·ªán n√∫t
      startButton.addEventListener("click", function() {
        resetDemo();
        animationPaused = false;
        animationRunning = true;
        startButton.disabled = true;
        pauseButton.disabled = false;
        continueButton.disabled = true;
        resetButton.disabled = false;
        startAnimation();
      });
      
      pauseButton.addEventListener("click", function() {
        animationPaused = true;
        pauseButton.disabled = true;
        continueButton.disabled = false;
        updateMessage("ƒê√£ t·∫°m d·ª´ng. Nh·∫•n 'Ti·∫øp t·ª•c' ƒë·ªÉ ti·∫øp t·ª•c.");
      });
      
      continueButton.addEventListener("click", function() {
        animationPaused = false;
        pauseButton.disabled = false;
        continueButton.disabled = true;
        updateMessage("ƒêang ti·∫øp t·ª•c...");
        
        // Ti·∫øp t·ª•c animation b·∫±ng c√°ch gi·∫£i quy·∫øt promise
        if (animationResolve) {
          animationResolve();
          animationResolve = null;
        }
      });
      
      resetButton.addEventListener("click", function() {
        resetDemo();
      });
      
      function resetDemo() {
        // Reset t·∫•t c·∫£ c√°c node v√† link
        myDiagram.nodes.each(function(node) {
          const shape = node.findObject("SHAPE");
          if (shape) {
            const data = node.data;
            shape.fill = data.color;
            shape.stroke = data.borderColor;
          }
          
          const detailsText = node.findObject("DETAILS");
          if (detailsText) {
            detailsText.stroke = "#555";
          }
          
          const currentAction = node.findObject("CURRENT_ACTION");
          if (currentAction) {
            currentAction.visible = false;
            currentAction.text = "";
          }
        });
        
        myDiagram.links.each(function(link) {
          const shape = link.findObject("SHAPE");
          if (shape) {
            shape.strokeWidth = 2;
          }
        });
        
        // X√≥a log v√† message
        clearLog();
        messageBox.innerText = "Ch·ªçn 'B·∫Øt ƒë·∫ßu Demo' ƒë·ªÉ b·∫Øt ƒë·∫ßu.";
        
        // Reset c√°c bi·∫øn ki·ªÉm so√°t animation
        animationPaused = false;
        animationRunning = false;
        if (animationResolve) {
          animationResolve();
          animationResolve = null;
        }
        
        // Reset c√°c n√∫t
        startButton.disabled = false;
        pauseButton.disabled = true;
        continueButton.disabled = true;
        resetButton.disabled = false;
      }
      
      // Tr√¨nh t·ª± animation
      async function startAnimation() {
        try {
          // Reset
          clearLog();
          clearAllCurrentActions();
          updateMessage("B·∫Øt ƒë·∫ßu workflow...");
          
          // Reset ActionPlan v·ªÅ tr·ªëng l√∫c ban ƒë·∫ßu
          updateActionPlan(0, false);
          
          // User g·ª≠i tin nh·∫Øn
          highlightNode("user", 1500);
          updateCurrentAction("user", "G·ª≠i tin nh·∫Øn: 'T√¥i ƒë√£ xong vi·ªác h√¥m nay'", true);
          addLogEntry("user", "User: 'T√¥i ƒë√£ xong vi·ªác h√¥m nay'");
          await sleep(1500);
          
          // G·ª≠i tin nh·∫Øn ƒë·∫øn Planning Agent
          highlightLink("user", "planning", "input");
          updateCurrentAction("user", "", false);
          await sleep(1000);
          
          // Planning Agent nh·∫≠n tin nh·∫Øn
          highlightNode("planning");
          updateCurrentAction("planning", "Nh·∫≠n tin nh·∫Øn t·ª´ user...", true);
          addLogEntry("planning", "Planning Agent: Nh·∫≠n tin nh·∫Øn t·ª´ user");
          updateMessage("Planning Agent ƒëang ph√¢n t√≠ch tin nh·∫Øn v√† t·∫°o action plan...");
          await sleep(1500);
          
          // Planning Agent t·∫°o action plan
          updateCurrentAction("planning", "T·∫°o action plan...", true);
          addLogEntry("planning", "Planning Agent: T·∫°o action plan v·ªõi 4 b∆∞·ªõc");
          updateMessage("Planning Agent ƒë√£ t·∫°o action plan d·ª±a tr√™n tin nh·∫Øn c·ªßa user");
          
          // T·∫°o v√† hi·ªÉn th·ªã Action Plan
          highlightLink("planning", "action_plan", "t·∫°o");
          await sleep(1000);
          highlightNode("action_plan");
          updateActionPlan(0, true); // Hi·ªÉn th·ªã action plan ban ƒë·∫ßu
          await sleep(1500);
          
          // Reset m√†u Planning Agent tr∆∞·ªõc khi chuy·ªÉn sang b∆∞·ªõc ti·∫øp theo
          const planningNode = myDiagram.findNodeForKey("planning");
          if (planningNode) {
            const planningShape = planningNode.findObject("SHAPE");
            if (planningShape) {
              planningShape.fill = planningNode.data.color;
              planningShape.stroke = planningNode.data.borderColor;
            }
          }
          
          // Command 1: Planning Agent -> Jira Agent (B∆∞·ªõc 1 c·ªßa action plan)
          updateActionPlan(1, true); // Highlight b∆∞·ªõc 1
          highlightNode("planning");
          highlightLink("planning", "jira", "ra l·ªánh");
          updateCurrentAction("planning", "G·ª≠i l·ªánh cho Jira Agent...", true);
          addLogEntry("planning", "Planning Agent ‚Üí Jira Agent: L·∫•y danh s√°ch task c·ªßa user h√¥m nay");
          updateMessage("G·ª≠i l·ªánh ƒë·∫øn Jira Agent: L·∫•y danh s√°ch task c·ªßa user h√¥m nay");
          await sleep(1500);
          
          // Reset m√†u Planning Agent tr∆∞·ªõc khi highlight Jira
          if (planningNode) {
            const planningShape = planningNode.findObject("SHAPE");
            if (planningShape) {
              planningShape.fill = planningNode.data.color;
              planningShape.stroke = planningNode.data.borderColor;
            }
          }
          
          // Jira Agent nh·∫≠n v√† th·ª±c thi l·ªánh
          highlightNode("jira");
          updateCurrentAction("planning", "", false);
          updateCurrentAction("jira", "ƒêang l·∫•y danh s√°ch task...", true);
          addLogEntry("jira", "Jira Agent: Nh·∫≠n l·ªánh l·∫•y danh s√°ch task");
          updateMessage("Jira Agent ƒëang th·ª±c thi: getJiraTasks(user, date)");
          await sleep(2000);
          
          // Jira Agent tr·∫£ k·∫øt qu·∫£
          updateCurrentAction("jira", "ƒê√£ t√¨m th·∫•y: XDEMO2-6", true);
          addLogEntry("jira", "Jira Agent: T√¨m th·∫•y task XDEMO2-6 'C·∫≠p nh·∫≠t t√≠nh nƒÉng ƒëƒÉng nh·∫≠p' (In Progress)");
          updateMessage("Jira Agent tr·∫£ v·ªÅ: Task XDEMO2-6 'C·∫≠p nh·∫≠t t√≠nh nƒÉng ƒëƒÉng nh·∫≠p' (In Progress, Assignee: Hung Nguyen)");
          await sleep(2000);
          
          // Reset m√†u Jira Agent tr∆∞·ªõc khi chuy·ªÉn sang b∆∞·ªõc ti·∫øp theo
          const jiraNode = myDiagram.findNodeForKey("jira");
          if (jiraNode) {
            const jiraShape = jiraNode.findObject("SHAPE");
            if (jiraShape) {
              jiraShape.fill = jiraNode.data.color;
              jiraShape.stroke = jiraNode.data.borderColor;
            }
          }
          
          // Command 2: Planning Agent -> Slack Agent (B∆∞·ªõc 2 c·ªßa action plan)
          updateActionPlan(2, true); // Highlight b∆∞·ªõc 2
          highlightNode("planning");
          highlightLink("planning", "slack", "ra l·ªánh");
          updateCurrentAction("jira", "", false);
          updateCurrentAction("planning", "G·ª≠i l·ªánh cho Slack Agent...", true);
          addLogEntry("planning", "Planning Agent ‚Üí Slack Agent: T√¨m tin nh·∫Øn li√™n quan ƒë·∫øn task XDEMO2-6");
          updateMessage("G·ª≠i l·ªánh ƒë·∫øn Slack Agent: T√¨m tin nh·∫Øn li√™n quan ƒë·∫øn task XDEMO2-6");
          await sleep(1500);
          
          // Reset m√†u Planning Agent tr∆∞·ªõc khi highlight Slack
          if (planningNode) {
            const planningShape = planningNode.findObject("SHAPE");
            if (planningShape) {
              planningShape.fill = planningNode.data.color;
              planningShape.stroke = planningNode.data.borderColor;
            }
          }
          
          // Slack Agent nh·∫≠n v√† th·ª±c thi l·ªánh
          highlightNode("slack");
          updateCurrentAction("planning", "", false);
          updateCurrentAction("slack", "ƒêang t√¨m tin nh·∫Øn...", true);
          addLogEntry("slack", "Slack Agent: Nh·∫≠n l·ªánh t√¨m tin nh·∫Øn");
          updateMessage("Slack Agent ƒëang th·ª±c thi: searchSlackMessages('XDEMO2-6')");
          await sleep(2000);
          
          // Slack Agent tr·∫£ k·∫øt qu·∫£
          updateCurrentAction("slack", "ƒê√£ t√¨m th·∫•y: 3 tin nh·∫Øn", true);
          addLogEntry("slack", "Slack Agent: T√¨m th·∫•y 3 tin nh·∫Øn li√™n quan ƒë·∫øn task XDEMO2-6");
          updateMessage("Slack Agent tr·∫£ v·ªÅ: 3 tin nh·∫Øn li√™n quan ƒë·∫øn task XDEMO2-6 trong k√™nh #project-channel");
          await sleep(2000);
          
          // Reset m√†u Slack Agent tr∆∞·ªõc khi chuy·ªÉn sang b∆∞·ªõc ti·∫øp theo
          const slackNode = myDiagram.findNodeForKey("slack");
          if (slackNode) {
            const slackShape = slackNode.findObject("SHAPE");
            if (slackShape) {
              slackShape.fill = slackNode.data.color;
              slackShape.stroke = slackNode.data.borderColor;
            }
          }
          
          // Command 3: Planning Agent -> Jira Agent (B∆∞·ªõc 3 c·ªßa action plan)
          updateActionPlan(3, true); // Highlight b∆∞·ªõc 3
          highlightNode("planning");
          highlightLink("planning", "jira", "ra l·ªánh");
          updateCurrentAction("slack", "", false);
          updateCurrentAction("planning", "G·ª≠i l·ªánh cho Jira Agent...", true);
          addLogEntry("planning", "Planning Agent ‚Üí Jira Agent: Log work 8h cho task XDEMO2-6 v√† chuy·ªÉn status th√†nh Done");
          updateMessage("G·ª≠i l·ªánh ƒë·∫øn Jira Agent: Log work 8h cho task XDEMO2-6 v√† chuy·ªÉn status th√†nh Done");
          await sleep(1500);
          
          // Reset m√†u Planning Agent tr∆∞·ªõc khi highlight Jira
          if (planningNode) {
            const planningShape = planningNode.findObject("SHAPE");
            if (planningShape) {
              planningShape.fill = planningNode.data.color;
              planningShape.stroke = planningNode.data.borderColor;
            }
          }
          
          // Jira Agent nh·∫≠n v√† th·ª±c thi l·ªánh l·∫ßn 2
          highlightNode("jira");
          updateCurrentAction("planning", "", false);
          updateCurrentAction("jira", "ƒêang c·∫≠p nh·∫≠t task...", true);
          addLogEntry("jira", "Jira Agent: Nh·∫≠n l·ªánh c·∫≠p nh·∫≠t task");
          updateMessage("Jira Agent ƒëang th·ª±c thi: updateJiraTask(XDEMO2-6, {status: 'Done', logwork: '8h'})");
          await sleep(2000);
          
          // Jira Agent tr·∫£ k·∫øt qu·∫£ c·∫≠p nh·∫≠t
          updateCurrentAction("jira", "ƒê√£ c·∫≠p nh·∫≠t: XDEMO2-6 ‚Üí Done", true);
          addLogEntry("jira", "Jira Agent: ƒê√£ c·∫≠p nh·∫≠t task XDEMO2-6 th√†nh c√¥ng (status: Done, logwork: 8h)");
          updateMessage("Jira Agent tr·∫£ v·ªÅ: Task XDEMO2-6 ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng (Now: Done)");
          await sleep(2000);
          
          // Reset m√†u Jira Agent tr∆∞·ªõc khi chuy·ªÉn sang b∆∞·ªõc ti·∫øp theo
          if (jiraNode) {
            const jiraShape = jiraNode.findObject("SHAPE");
            if (jiraShape) {
              jiraShape.fill = jiraNode.data.color;
              jiraShape.stroke = jiraNode.data.borderColor;
            }
          }
          
          // Command 4: Planning Agent -> Confluence Agent (B∆∞·ªõc 4 c·ªßa action plan)
          updateActionPlan(4, true); // Highlight b∆∞·ªõc 4
          highlightNode("planning");
          highlightLink("planning", "confluence", "ra l·ªánh");
          updateCurrentAction("jira", "", false);
          updateCurrentAction("planning", "G·ª≠i l·ªánh cho Confluence Agent...", true);
          addLogEntry("planning", "Planning Agent ‚Üí Confluence Agent: T·∫°o daily meeting note v·ªõi n·ªôi dung ho√†n th√†nh task");
          updateMessage("G·ª≠i l·ªánh ƒë·∫øn Confluence Agent: T·∫°o daily meeting note v·ªõi n·ªôi dung ho√†n th√†nh task");
          await sleep(1500);
          
          // Reset m√†u Planning Agent tr∆∞·ªõc khi highlight Confluence
          if (planningNode) {
            const planningShape = planningNode.findObject("SHAPE");
            if (planningShape) {
              planningShape.fill = planningNode.data.color;
              planningShape.stroke = planningNode.data.borderColor;
            }
          }
          
          // Confluence Agent nh·∫≠n v√† th·ª±c thi l·ªánh
          highlightNode("confluence");
          updateCurrentAction("planning", "", false);
          updateCurrentAction("confluence", "ƒêang t·∫°o daily meeting note...", true);
          addLogEntry("confluence", "Confluence Agent: Nh·∫≠n l·ªánh t·∫°o daily meeting note");
          updateMessage("Confluence Agent ƒëang th·ª±c thi: createConfluencePage('Daily Meeting', content)");
          await sleep(2000);
          
          // Confluence Agent tr·∫£ k·∫øt qu·∫£
          updateCurrentAction("confluence", "ƒê√£ t·∫°o: Daily Meeting Note", true);
          addLogEntry("confluence", "Confluence Agent: ƒê√£ t·∫°o trang Daily Meeting Note th√†nh c√¥ng");
          updateMessage("Confluence Agent tr·∫£ v·ªÅ: ƒê√£ t·∫°o trang Daily Meeting Note v·ªõi th√¥ng tin task ƒë√£ ho√†n th√†nh");
          await sleep(2000);
          
          // Reset m√†u Confluence Agent tr∆∞·ªõc khi chuy·ªÉn sang b∆∞·ªõc ti·∫øp theo
          const confluenceNode = myDiagram.findNodeForKey("confluence");
          if (confluenceNode) {
            const confluenceShape = confluenceNode.findObject("SHAPE");
            if (confluenceShape) {
              confluenceShape.fill = confluenceNode.data.color;
              confluenceShape.stroke = confluenceNode.data.borderColor;
            }
          }
          
          // Ho√†n th√†nh t·∫•t c·∫£ c√°c b∆∞·ªõc trong Action Plan
          updateActionPlan(5, false); // ƒê√°nh d·∫•u t·∫•t c·∫£ b∆∞·ªõc ƒë√£ ho√†n th√†nh
          
          // Planning Agent k·∫øt th√∫c action plan
          highlightNode("planning");
          updateCurrentAction("confluence", "", false);
          updateCurrentAction("planning", "Ho√†n th√†nh to√†n b·ªô action plan ‚úì", true);
          addLogEntry("planning", "Planning Agent: Ho√†n th√†nh to√†n b·ªô action plan ‚úì");
          updateMessage("Planning Agent ƒë√£ ho√†n th√†nh to√†n b·ªô action plan. T·∫•t c·∫£ c√°c nhi·ªám v·ª• ƒë√£ ƒë∆∞·ª£c th·ª±c hi·ªán th√†nh c√¥ng! ‚úì");
          
          // Ph·∫£n h·ªìi c·ªßa user
          await sleep(2000);
          // Reset m√†u Planning Agent tr∆∞·ªõc khi highlight User
          if (planningNode) {
            const planningShape = planningNode.findObject("SHAPE");
            if (planningShape) {
              planningShape.fill = planningNode.data.color;
              planningShape.stroke = planningNode.data.borderColor;
            }
          }
          
          highlightNode("user");
          updateCurrentAction("planning", "", false);
          updateCurrentAction("user", "C·∫£m ∆°n!", true);
          addLogEntry("user", "User: C·∫£m ∆°n!");
          await sleep(1000);
          
          // Reset m√†u User node khi k·∫øt th√∫c
          const userNode = myDiagram.findNodeForKey("user");
          if (userNode) {
            const userShape = userNode.findObject("SHAPE");
            if (userShape) {
              userShape.fill = userNode.data.color;
              userShape.stroke = userNode.data.borderColor;
            }
          }
        } finally {
          // D·ªçn d·∫πp khi animation k·∫øt th√∫c ho·∫∑c b·ªã gi√°n ƒëo·∫°n
          animationRunning = false;
          startButton.disabled = false;
          pauseButton.disabled = true;
          continueButton.disabled = true;
        }
      }
      
      // Th√™m event listener tr·ª±c ti·∫øp (kh√¥ng ph·ª• thu·ªôc v√†o DOMContentLoaded)
      window.onload = function() {
        // G·ªçi h√†m startAnimation t·ª´ ph·∫°m vi window
        window.runAgentAnimation = startAnimation;
        window.resetDemo = resetDemo;
      };
    });
  </script>
</body>
</html> 